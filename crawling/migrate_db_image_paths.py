#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
One-time script to migrate absolute image paths in the PhotoURL table
to relative paths (relative to the 'public' folder).
"""
import os
import time
import traceback
from db_manager import get_db_connection # Assuming db_manager.py is in the same directory or accessible
import crawling.crawling_auction_ongoing.config as config # For DEBUG flag or other configs if needed

# --- Configuration ---
PUBLIC_DIR_NAME = "public"  # Name of your public directory
# Path patterns to identify absolute paths (customize if needed)
# This pattern tries to match Windows-style paths starting with a drive letter
# or Unix-style paths starting with /
ABSOLUTE_PATH_START_PATTERNS = [":\\", ":/", "/"] # C:\, C:/, / (for Unix-like if any)

# For Windows, common project root part to help identify project-specific absolute paths
# This helps to avoid accidentally trying to convert system paths if any were mistakenly stored.
# Example: 'C:\\Users\\WIN\\StudioProjects\\courtauction_car'
# If your DB might contain other types of absolute paths you don't want to touch,
# make this more specific. For now, we'll rely on the PUBLIC_DIR_NAME split.
PROJECT_ROOT_IDENTIFIER = "courtauction_car" # A segment of your project's absolute path

def convert_to_relative_path(absolute_path, public_dir_name):
    """
    Converts an absolute file path to a path relative to the public directory.
    Example: "C:\\path\\to\\project\\public\\uploads\\image.png" -> "uploads/image.png"
    """
    if not isinstance(absolute_path, str):
        return None

    try:
        # Normalize path separators for consistent splitting
        normalized_path = absolute_path.replace("\\", "/")
        
        # Split path by "public/"
        # We add / after public_dir_name to ensure we split at the directory, not just the word
        split_key = f"{public_dir_name}/"
        parts = normalized_path.split(split_key, 1) # Split only on the first occurrence

        if len(parts) > 1 and parts[1]:
            return parts[1] # Return the part after "public/"
        else:
            # Fallback or alternative logic if the above split doesn't work as expected
            # This might happen if the path doesn't contain "public/" in the expected way
            # For example, if image_storage_path was 'C:/.../courtauction_car/data/public_images'
            # and public_dir_name was just 'public_images'.
            # A more robust way might involve knowing the full absolute path to the public_dir_name
            # and using os.path.relpath, but that requires config.IMAGE_STORAGE_PATH
            # or similar to be accurately set reflecting the structure for ALL stored paths.
            # For now, we assume the simple split is sufficient for paths generated by the old script.
            if config.DEBUG:
                print(f"DEBUG: Could not convert using simple split: {absolute_path}. Trying basename as last resort if it seems like a filename.")
            # If it looks like a filename at the end of a path, maybe just return that?
            # This is a very basic fallback.
            basename = os.path.basename(normalized_path)
            if '.' in basename : # Simple check for a file extension
                return basename # This might be too aggressive or not what's needed.
            return None # Indicates conversion failure
            
    except Exception as e:
        print(f"Error converting path '{absolute_path}': {e}")
        return None

def main():
    db_conn = None
    updated_count = 0
    failed_count = 0
    processed_count = 0

    print(f"{time.strftime('%H:%M:%S')} - Starting PhotoURL image path migration script.")

    try:
        db_conn = get_db_connection()
        if not db_conn:
            print(f"{time.strftime('%H:%M:%S')} - Database connection failed. Exiting.")
            return

        cursor = db_conn.cursor()

        # Fetch all PhotoURL records
        # Assuming 'id' is the primary key and 'image_path_or_url' is the column to update.
        # Adjust table and column names if different.
        # The schema shows PhotoURL has an 'id' (uuid), 'auction_no', 'photo_index', 'image_path_or_url'
        # We need the 'id' to update the specific row.
        select_query = "SELECT id, image_path_or_url FROM \"PhotoURL\";"
        cursor.execute(select_query)
        records = cursor.fetchall()

        if not records:
            print(f"{time.strftime('%H:%M:%S')} - No records found in PhotoURL table. Nothing to migrate.")
            return

        print(f"{time.strftime('%H:%M:%S')} - Found {len(records)} records in PhotoURL table. Starting migration...")

        for record_id, current_path in records:
            processed_count += 1
            if not current_path or not isinstance(current_path, str):
                if config.DEBUG: print(f"DEBUG: Record ID {record_id}: Path is empty or not a string ('{current_path}'). Skipping.")
                continue

            # Check if the path looks like an absolute path we want to convert
            # It should contain the project identifier and start with common absolute path patterns
            is_potentially_absolute = any(pattern in current_path for pattern in ABSOLUTE_PATH_START_PATTERNS)
            contains_project_id = PROJECT_ROOT_IDENTIFIER in current_path
            
            # More specific check: does it contain 'public' folder name? This is key.
            is_target_absolute_path = (os.sep + PUBLIC_DIR_NAME + os.sep) in current_path or \
                                      ("/" + PUBLIC_DIR_NAME + "/") in current_path.replace("\\", "/")


            if is_target_absolute_path:
                if config.DEBUG: print(f"DEBUG: Record ID {record_id}: Processing absolute path '{current_path}'")
                
                relative_path = convert_to_relative_path(current_path, PUBLIC_DIR_NAME)

                if relative_path and relative_path != current_path:
                    try:
                        update_query = "UPDATE \"PhotoURL\" SET image_path_or_url = %s WHERE id = %s;"
                        cursor.execute(update_query, (relative_path, record_id))
                        print(f"{time.strftime('%H:%M:%S')} - Record ID {record_id}: Migrated '{current_path}' -> '{relative_path}'")
                        updated_count += 1
                    except Exception as e_update:
                        print(f"{time.strftime('%H:%M:%S')} - ERROR: Failed to update Record ID {record_id} ('{current_path}'). Error: {e_update}")
                        traceback.print_exc()
                        db_conn.rollback() # Rollback this specific item's change or the whole batch later
                        failed_count += 1
                        # Decide if you want to stop on first error or continue
                        # For now, it continues and reports failures at the end
                elif relative_path == current_path:
                    if config.DEBUG: print(f"DEBUG: Record ID {record_id}: Path '{current_path}' conversion resulted in same path. No update needed.")
                else:
                    print(f"{time.strftime('%H:%M:%S')} - WARNING: Record ID {record_id}: Failed to convert path '{current_path}'. It will be left unchanged.")
                    failed_count += 1
            else:
                if config.DEBUG:
                    # Log if it's not an http path and not a target absolute path, just for review
                    if not current_path.startswith('http://') and not current_path.startswith('https://'):
                         print(f"DEBUG: Record ID {record_id}: Path '{current_path}' does not appear to be a target absolute path for conversion. Skipping.")
                    else:
                         print(f"DEBUG: Record ID {record_id}: Path '{current_path}' is an HTTP(S) URL. Skipping.")


        if updated_count > 0 or failed_count > 0: # Only commit if there were actual attempts
            if failed_count == 0 and updated_count > 0:
                print(f"{time.strftime('%H:%M:%S')} - All successful updates will be committed.")
                db_conn.commit()
            elif updated_count > 0 and failed_count > 0:
                print(f"{time.strftime('%H:%M:%S')} - Partial success: {updated_count} updated, {failed_count} failed. Changes for successful updates will be committed.")
                # db_conn.commit() # Decide if partial commit is okay. For safety, might prefer all-or-nothing.
                # For now, let's commit successful ones if any, as rollback was per item on error.
                # However, if any single cursor.execute() fails, the transaction might be in aborted state for some DBs.
                # A safer approach for batch updates is to collect all changes and do one commit at the end,
                # or handle exceptions more globally for the batch.
                # Given the current loop, rollback is per item, so commit should be fine for successful ones.
                db_conn.commit() # Committing successfully updated rows
                print(f"{time.strftime('%H:%M:%S')} - WARNING: {failed_count} items could not be updated. Please review logs.")
            elif failed_count > 0 and updated_count == 0:
                 print(f"{time.strftime('%H:%M:%S')} - No records were successfully updated. All {failed_count} attempts failed. No changes committed.")
                 db_conn.rollback() # Ensure nothing is committed if all failed
            else: # No updates, no fails (e.g. all paths were already relative or http)
                print(f"{time.strftime('%H:%M:%S')} - No paths required migration or no updates were made.")
        else:
            print(f"{time.strftime('%H:%M:%S')} - No records processed that required an update attempt.")

        print(f"{time.strftime('%H:%M:%S')} - Migration finished. Processed: {processed_count}, Updated: {updated_count}, Failed: {failed_count}.")

    except Exception as e:
        print(f"{time.strftime('%H:%M:%S')} - An unexpected error occurred during migration: {e}")
        print(traceback.format_exc())
        if db_conn:
            db_conn.rollback()
    finally:
        if db_conn:
            db_conn.close()
            print(f"{time.strftime('%H:%M:%S')} - Database connection closed.")

if __name__ == "__main__":
    # If config.py uses dotenv, load it here as well
    # from dotenv import load_dotenv
    # dotenv_path_project_root = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), '.env')
    # if os.path.exists(dotenv_path_project_root):
    #     load_dotenv(dotenv_path=dotenv_path_project_root)
    # else:
    #     load_dotenv() # Default location

    # Or ensure config.py handles its own .env loading if needed
    main() 